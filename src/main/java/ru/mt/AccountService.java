package ru.mt;

import java.util.Collections;
import java.util.Set;

/**
 *   Сервис, через который выполняются все операции со счетами.
 *
 *   Запросы по созданию счетов выполняет сам.
 *
 *   Запросы по работе с балансом счета проксирует к AccountBalanceManager-ам,
 *   но при этом реализует логику синхронного вызова AccountBalanceManager-ов,
 *   которые работают асинхронно через обработку вызовов из таблицы account_balance_call, у которой колонки:
 *   - ИД счета, для которого адресован вызов (PK) - по этой колонке выполняем партиционирование
 *   - ИД вызова
 *   - timestamp
 *   - имя вызываемого метода
 *   - параметры
 *   - результат выполнения
 *
 *   Смысл в этой таблице с запросами в том, чтобы упорядочить запросы к AccountBalanceManager-ам, которых может быть несколько экземпляров.
 *   Но при этом обычная очередь не подойдет, потому что выполнение метода в AccountService должно быть синхронным, а следовательно,
 *   нужно не только отправить запрос в AccountBalanceManager, но и дождаться результата его выполнения.
 *
 *   логика работы:
 *   - при вызове любого метода у AccountService он создает новую запись в account_balance_call
 *     ! важно, что AccountService работает с account_balance_call только через insert и select, но update ему делать нельзя!
 *   - далее периодически проверяет, появился ли результат выполнения (который должен проставить AccountBalanceManager)
 *   - если появился, то возвращает его
 *   - иначе, ждет таймаут и снова проверяет
 *   (*) можно подумать, как лучше реализовать ожидание... например, через какой то аналог корутин (Go, Kotlin) или
 *      через "подписку на события", которую сделать через очередь.
 *   (*) можно сделать макс. время ожидание для случаев, когда на вызов долго не обрабатывается (AccountBalanceManager сломался).
 *     А также сделать отдельный сервис, который проставляет результат "Ошибка" для вызовов, которые так и не были обработаны.
 *
 *   Также отвечает за
 *     - создание AccountBalanceManager-ов и распределение между ними счетов
 *     - перебалансировку AccountBalanceManager-ов в случаях, когда какие то выходят из строя, или наоборот создаются новые
 */
public class AccountService {

    /**
     * Получить список счетов
     * @return список идентификаторов счетов
     */
    public Set<String> getAccounts() {
        // select id from account
        return Collections.emptySet();
    }

    /**
     * Создать новый счет
     * @return
     */
    public String createNewAccount() {
        // создает новый счет в БД
        // (?) назначает AccountManager-а, который отвечает за этот счет
        return null;
    }

    /**
     * Получить баланс счета
     * @param accountId
     * @return
     */
    public double getAccountBalance(String accountId) {
        // зарегистрировать вызов к AccountBalanceManager-у, ждать результат выполнения
        return 0;
    }
}
